// 咖啡商店类：可以根据咖啡名点咖啡
// 咖啡类：有加糖和加奶的方法和抽象方法获取名字
// 美式咖啡、拿铁咖啡类重写了自己的名字
// 存在的问题：如果需要加一种新的咖啡，就必须修改咖啡商店的代码，违背开闭原则。如果咖啡店开了1000家，意味着需要在1000个不同的地方修改代码

// 简单工厂的修改方案：其实这部分代码在所有的咖啡店内都需要增加相同的判断
// 那干脆把这部分抽出来变成一个工厂类，让其他所有的咖啡店去调用这个工厂类，具体逻辑也在工厂类中实现
// 简单工厂存在的问题，违背开闭原则

// 工厂方法的修改方案：由于简单工厂在增加新咖啡品种时，还是需要修改原先类中的代码，违背了开闭原则，对这部分进行提取
// 新增抽象工厂接口，并实现美式咖啡工厂和拿铁咖啡工厂，实现咖啡的实例化（对用户隐藏了咖啡实例化具体的方法）
// 商店类中需要传入具体的咖啡工厂类，并通过这个工厂类创建的咖啡交付给用户（SetFactory和OrderCoffee）
// 这样以后如果需要新的摩卡咖啡类，只需要新建一个具体的摩卡咖啡工厂类，之后在咖啡商店类设置工厂即可，原先类的代码都不需要进行修改
// 工厂方法的问题：如果有100种咖啡，然后又有100种蛋糕，100种盘子....意味着有300个具体的工厂，可能会导致类的爆炸

// 抽象工厂方法的方案：如果这些咖啡、蛋糕之间有一定的关系，比如风格的关系，也就是他是在产品的系列上进行扩展，而非产品的种类上进行扩展
// 可以考虑把这些同风格的产品都放进一个工厂内，也就是抽象工厂拥有制造蛋糕和咖啡的抽象方法
// 具体工厂A可以生产美式咖啡、美式甜品，B可以生产英式咖啡、英式甜品
// 重点在于它的生产结构没有发生变化，都是咖啡+甜品的结构，只是系列发生了扩展
// 缺点：如果结构发生了扩展，所有工厂都需要发生扩展
// 实际上也不能称之为缺点，只是抽象工厂的特点是用于解决系列扩展的问题
namespace Factory_Cofe_AbstractFacttory
{
    internal class Program
    {
        public static void Main(string[] args)
        {
        }
    }
}